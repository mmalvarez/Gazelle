theory Auto_Lifter_Proofs
  imports Lifter Lifter_Instances Auto_Lifter "Velocity/Schem_Lift_Defs"
begin

(* 
 * In this file, we have some rather basic proof automation (really just lemma-lists to supply
 * to Isabelle's automation) to support reasoning about the output of the schem_lift automation
 * (see Auto_Lifter.thy) without having to manually unfold definitions and dig into the
 * details of what that lifting is actually doing.
 *
 * This file (currently) supports proving
 * various notions of validity (see Lifter.thy) for the liftings 
 * generated by the auto lifter. This tends to be straightforward since the auto lifter
 * is really just composing liftings already known to be valid. However, sometimes the
 * lifting transformers involved have nontrivial side-conditions, which can make the proof
 * more difficult. We aim to at least handle the easy cases effortlessly.
 *
 * One common case where the proof can become a bit more challenging but should still be
 * relatively easy to automate is when the side-condition stipulates that a pair of liftings
 * needs to be orthogonal in order for the lifting to be valid. Such cases can also be automatable
 * if the orthogonality falls directly out of the structure of the liftings involved
 * (e.g. when merging fst_l and snd_l, orthogonality is trivial)
 *)

(* TODO: automation for orthogonality, sups_pres, etc. (side-conditions on when merging
 * two or more semantics is well defined) *)

(* vsg versions add a side condition on equality of the valid set,
   which might make them more useful. *)



lemmas lifting_defs =
  prio_l_inc_def
  prio_l_inc2_def
  prio_l_incN_def
  prio_l_case_inc_def

(* definitions for breaking up compound locales *)
lemmas lifting_valid_locale_intro = 
  lifting_valid.intro
  lifting_valid_weak_base.intro
  lifting_valid_base.intro
  lifting_valid_weak_ok.intro
  lifting_valid_ok.intro
  lifting_valid_weak_base_ok.intro
  lifting_valid_base_ok.intro
  lifting_valid_weak_pres.intro
  lifting_valid_pres.intro
  lifting_valid_weak_base_pres.intro
  lifting_valid_base_pres.intro
  lifting_valid_weak_ok_pres.intro
  lifting_valid_ok_pres.intro
  lifting_valid_weak_base_ok_pres.intro
  lifting_valid_base_ok_pres.intro
  lifting_valid_weak_pairwise.intro
  lifting_valid_pairwise.intro
  lifting_valid_weak_base_pairwise.intro
  lifting_valid_base_pairwise.intro
  lifting_valid_weak_ok_pairwise.intro
  lifting_valid_ok_pairwise.intro
  lifting_valid_weak_base_ok_pairwise.intro
  lifting_valid_base_ok_pairwise.intro
  lifting_valid_weak_pres_pairwise.intro
  lifting_valid_pres_pairwise.intro
  lifting_valid_weak_base_pres_pairwise.intro
  lifting_valid_base_pres_pairwise.intro
  lifting_valid_weak_ok_pres_pairwise.intro
  lifting_valid_ok_pres_pairwise.intro
  lifting_valid_weak_base_ok_pres_pairwise.intro
  lifting_valid_base_ok_pres_pairwise.intro

(* TODO: do we need putonly instances? *)
(* TODO: do we need ax or just ax_g? *)
lemmas lifting_valid_noaxiom =
lifting_valid_locale_intro 

  id_l.lifting_putonly_axioms
  id_l.lifting_valid_weak_axioms


  triv_l.lifting_putonly_axioms
  triv_l.lifting_valid_weak_axioms
  triv_l.lifting_valid_pres_ext_axioms
  triv_l.lifting_valid_ok_ext_axioms
  triv_l.lifting_valid_pairwise_ext_axioms


  option_l_valid_weak.intro
  (*option_l_valid_weak.axioms*)
  option_l_valid_weak.ax_g

  option_l_valid_ext.intro
  (*option_l_valid_ext.axioms*)
  option_l_valid_ext.ax

  option_l_valid_base_ext.ax

  option_l_valid_ok_ext.intro
  (*option_l_valid_ok_ext.axioms*)
  option_l_valid_ok_ext.ax_g

  option_l_valid_pres_ext.intro
  (*option_l_valid_pres_ext.axioms*)
  option_l_valid_pres_ext.ax_g

  option_l_valid_base_pres_ext.intro
  (*option_l_valid_base_pres_ext.axioms*)
  option_l_valid_base_pres_ext.ax_g

  option_l_valid_pairwise_ext.intro
  (*option_l_valid_pairwise_ext.axioms*)
  option_l_valid_pairwise_ext.ax_g


  prio_l_valid_weak.intro
  (*prio_l_valid_weak.axioms*)
  prio_l_valid_weak.ax_g
prio_l_valid_weak'.intro
(*
prio_l_valid_ext.intro
(*prio_l_valid_ext.axioms*)
prio_l_valid_ext.ax
*)

prio_l_valid_ext_strong.intro
(*prio_l_valid_ext_strong.axioms*)
prio_l_valid_ext_strong.ax
prio_l_valid_ext_strong'.intro

(*
prio_l_valid_ext_stronger.intro
(*prio_l_valid_ext_stronger.axioms*)
prio_l_valid_ext_stronger.ax_g
*)
prio_l_valid_base_ext.intro
(*prio_l_valid_base_ext.axioms*)
prio_l_valid_base_ext.ax
prio_l_valid_base'.intro

prio_l_valid_ok_ext.intro
(*prio_l_valid_ok_ext.axioms*)
prio_l_valid_ok_ext.ax_g

(*
prio_l_valid_ext_stronger_ok.intro
(*prio_l_valid_ext_stronger_ok.axioms*)
prio_l_valid_ext_stronger_ok.ax_g
*)

prio_l_valid_base_ok_pres.intro
(*prio_l_valid_base_ok_pres.axioms*)
prio_l_valid_base_ok_pres.ax_g

prio_l_valid_pairwise_ext.intro
(*prio_l_valid_pairwise_ext.axioms*)
prio_l_valid_pairwise_ext.ax_g


  fst_l_valid_weak.intro
(*fst_l_valid_weak.axioms*)
fst_l_valid_weak.ax_g

  fst_l_valid_ext.intro
(*fst_l_valid_ext.axioms*)
fst_l_valid_ext.ax

  fst_l_valid_base_ext.intro
(*fst_l_valid_base_ext.axioms*)
fst_l_valid_base_ext.ax

fst_l_valid_ok_ext.intro
(*fst_l_valid_ok_ext.axioms*)
fst_l_valid_ok_ext.ax

fst_l_valid_pres_ext.intro
(*fst_l_valid_pres_ext.axioms*)
fst_l_valid_pres_ext.ax_g

fst_l_valid_base_pres_ext.intro
(*fst_l_valid_base_pres_ext.axioms*)
fst_l_valid_base_pres_ext.ax_g


  snd_l_valid_weak.intro
(*snd_l_valid_weak.axioms*)
snd_l_valid_weak.ax_g

  snd_l_valid_ext.intro
(*snd_l_valid_ext.axioms*)
snd_l_valid_ext.ax

  snd_l_valid_base_ext.intro
(*snd_l_valid_base_ext.axioms*)
snd_l_valid_base_ext.ax

snd_l_valid_ok_ext.intro
(*snd_l_valid_ok_ext.axioms*)
snd_l_valid_ok_ext.ax

snd_l_valid_pres_ext.intro
(*snd_l_valid_pres_ext.axioms*)
snd_l_valid_pres_ext.ax_g

snd_l_valid_base_pres_ext.intro
(*snd_l_valid_base_pres_ext.axioms*)
snd_l_valid_base_pres_ext.ax_g


merge_l_valid_weak.intro
(*merge_l_valid_weak.axioms*)
(*merge_l_valid_weak.ax_g*)
(* ax_g for merg_l seems to cause diverging behavior... *)
merge_l_valid_weak.ax

merge_l_valid_ext.intro
(*merge_l_valid_ext.axioms*)
merge_l_valid_ext.ax

merge_l_valid_base_ext.intro
(*merge_l_valid_base_ext.axioms*)
merge_l_valid_base_ext.ax

merge_l_valid_ok_ext.intro
(*merge_l_valid_ok_ext.axioms*)
merge_l_valid_ok_ext.ax_g

(* NB: don't have pres proofs for merge (likely not true in general) *)

merge_l_valid_pairwise_ext.intro
(*merge_l_valid_pairwise_ext.axioms*)
merge_l_valid_pairwise_ext.ax_g

lemmas lifting_valid_noaxiom_nog =
lifting_valid_locale_intro 

  id_l.lifting_putonly_axioms
  id_l.lifting_valid_weak_axioms


  triv_l.lifting_putonly_axioms
  triv_l.lifting_valid_weak_axioms
  triv_l.lifting_valid_pres_ext_axioms
  triv_l.lifting_valid_ok_ext_axioms
  triv_l.lifting_valid_pairwise_ext_axioms


  option_l_valid_weak.intro
  (*option_l_valid_weak.axioms*)
  option_l_valid_weak.ax

  option_l_valid_ext.intro
  (*option_l_valid_ext.axioms*)
  option_l_valid_ext.ax

  option_l_valid_base_ext.ax

  option_l_valid_ok_ext.intro
  (*option_l_valid_ok_ext.axioms*)
  option_l_valid_ok_ext.ax

  option_l_valid_pres_ext.intro
  (*option_l_valid_pres_ext.axioms*)
  option_l_valid_pres_ext.ax

  option_l_valid_base_pres_ext.intro
  (*option_l_valid_base_pres_ext.axioms*)
  option_l_valid_base_pres_ext.ax

  option_l_valid_pairwise_ext.intro
  (*option_l_valid_pairwise_ext.axioms*)
  option_l_valid_pairwise_ext.ax


  prio_l_valid_weak.intro
  (*prio_l_valid_weak.axioms*)
  prio_l_valid_weak.ax
prio_l_valid_weak'.intro
(*
prio_l_valid_ext.intro
(*prio_l_valid_ext.axioms*)
prio_l_valid_ext.ax
*)

prio_l_valid_ext_strong.intro
(*prio_l_valid_ext_strong.axioms*)
prio_l_valid_ext_strong.ax
prio_l_valid_ext_strong'.intro

(*
prio_l_valid_ext_stronger.intro
(*prio_l_valid_ext_stronger.axioms*)
prio_l_valid_ext_stronger.ax_g
*)
prio_l_valid_base_ext.intro
(*prio_l_valid_base_ext.axioms*)
prio_l_valid_base_ext.ax
prio_l_valid_base'.intro

prio_l_valid_ok_ext.intro
(*prio_l_valid_ok_ext.axioms*)
prio_l_valid_ok_ext.ax

(*
prio_l_valid_ext_stronger_ok.intro
(*prio_l_valid_ext_stronger_ok.axioms*)
prio_l_valid_ext_stronger_ok.ax_g
*)

prio_l_valid_base_ok_pres.intro
(*prio_l_valid_base_ok_pres.axioms*)
prio_l_valid_base_ok_pres.ax

prio_l_valid_pairwise_ext.intro
(*prio_l_valid_pairwise_ext.axioms*)
prio_l_valid_pairwise_ext.ax


  fst_l_valid_weak.intro
(*fst_l_valid_weak.axioms*)
fst_l_valid_weak.ax

  fst_l_valid_ext.intro
(*fst_l_valid_ext.axioms*)
fst_l_valid_ext.ax

  fst_l_valid_base_ext.intro
(*fst_l_valid_base_ext.axioms*)
fst_l_valid_base_ext.ax

fst_l_valid_ok_ext.intro
(*fst_l_valid_ok_ext.axioms*)
fst_l_valid_ok_ext.ax

fst_l_valid_pres_ext.intro
(*fst_l_valid_pres_ext.axioms*)
fst_l_valid_pres_ext.ax

fst_l_valid_base_pres_ext.intro
(*fst_l_valid_base_pres_ext.axioms*)
fst_l_valid_base_pres_ext.ax


  snd_l_valid_weak.intro
(*snd_l_valid_weak.axioms*)
snd_l_valid_weak.ax

  snd_l_valid_ext.intro
(*snd_l_valid_ext.axioms*)
snd_l_valid_ext.ax

  snd_l_valid_base_ext.intro
(*snd_l_valid_base_ext.axioms*)
snd_l_valid_base_ext.ax

snd_l_valid_ok_ext.intro
(*snd_l_valid_ok_ext.axioms*)
snd_l_valid_ok_ext.ax

snd_l_valid_pres_ext.intro
(*snd_l_valid_pres_ext.axioms*)
snd_l_valid_pres_ext.ax

snd_l_valid_base_pres_ext.intro
(*snd_l_valid_base_pres_ext.axioms*)
snd_l_valid_base_pres_ext.ax


merge_l_valid_weak.intro
(*merge_l_valid_weak.axioms*)
(*merge_l_valid_weak.ax_g*)
(* ax_g for merg_l seems to cause diverging behavior... *)
merge_l_valid_weak.ax

merge_l_valid_ext.intro
(*merge_l_valid_ext.axioms*)
merge_l_valid_ext.ax

merge_l_valid_base_ext.intro
(*merge_l_valid_base_ext.axioms*)
merge_l_valid_base_ext.ax

merge_l_valid_ok_ext.intro
(*merge_l_valid_ok_ext.axioms*)
merge_l_valid_ok_ext.ax

(* NB: don't have pres proofs for merge (likely not true in general) *)

merge_l_valid_pairwise_ext.intro
(*merge_l_valid_pairwise_ext.axioms*)
merge_l_valid_pairwise_ext.ax

lemmas lifting_valid_set_defs =
  option_l_S_def
  prio_l_S_def
  fst_l_S_def
  snd_l_S_def

lemmas lifting_ortho_locale_intro =
  l_ortho_pres.intro
l_ortho_base.intro
l_ortho_base_pres.intro
l_ortho_ok.intro
l_ortho_ok_pres.intro
l_ortho_base_ok_pres.intro

(* TODO: separate out orthogonality lemmas or no? *)
lemmas lifting_ortho_noaxiom =

lifting_ortho_locale_intro

  option_l_ortho.intro
(*option_l_ortho.axioms*)
option_l_ortho.ax_g

option_l_ortho_base_ext.intro
(*option_l_ortho_base_ext.axioms*)
option_l_ortho_base_ext.ax

option_l_ortho_ok_ext.intro
(*option_l_ortho_ok_ext.axioms*)


fst_l_ortho.intro
(*fst_l_ortho.axioms*)
fst_l_ortho.ax_g

fst_l_ortho_base_ext.intro
(*fst_l_ortho_base_ext.axioms*)
fst_l_ortho_base_ext.ax
(*
fst_l_ortho_ok_ext.intro
fst_l_ortho_ok_ext.axioms
*)

snd_l_ortho.intro
(*snd_l_ortho.axioms*)
snd_l_ortho.ax_g

snd_l_ortho_base_ext.intro
(*snd_l_ortho_base_ext.axioms*)
snd_l_ortho_base_ext.ax
(*
snd_l_ortho_ok_ext.intro
snd_l_ortho_ok_ext.axioms
*)

fst_l_snd_l_ortho.intro
(*fst_l_snd_l_ortho.axioms*)
fst_l_snd_l_ortho.ax_g
fst_l_snd_l_ortho.ax_g_comm

fst_l_snd_l_ortho_base_ext.intro
(*fst_l_snd_l_ortho_base_ext.axioms*)
fst_l_snd_l_ortho_base_ext.ax
fst_l_snd_l_ortho_base_ext.ax_comm

(*
fst_l_snd_l_ortho_ok_ext.intro
fst_l_snd_l_ortho_ok_ext.axioms
*)

merge_l_ortho.intro
(*merge_l_ortho.axioms*)
(* might wish to use ax_g' instead? *)
(*merge_l_ortho.ax_g
merge_l_ortho.ax_g_comm*)
(* as with merge lifting validity, using the _g version here
 * seems to cause divergence in the automation 
 * probably to do with the use of set intersection
 * hopefully this isn't a problem, or we can find some
 * simplification or other rule to eliminate.
 *)
merge_l_ortho.ax
merge_l_ortho.ax_comm

merge_l_ortho_base_ext.intro
(*merge_l_ortho_base_ext.axioms*)
merge_l_ortho_base_ext.ax
merge_l_ortho_base_ext.ax_comm
(*
merge_l_ortho_ok_ext.intro
merge_l_ortho_ok_ext.axioms
*)

lemmas lifting_ortho_noaxiom_nog =

lifting_ortho_locale_intro

  option_l_ortho.intro
(*option_l_ortho.axioms*)
option_l_ortho.ax

option_l_ortho_base_ext.intro
(*option_l_ortho_base_ext.axioms*)
option_l_ortho_base_ext.ax

option_l_ortho_ok_ext.intro
(*option_l_ortho_ok_ext.axioms*)


fst_l_ortho.intro
(*fst_l_ortho.axioms*)
fst_l_ortho.ax

fst_l_ortho_base_ext.intro
(*fst_l_ortho_base_ext.axioms*)
fst_l_ortho_base_ext.ax
(*
fst_l_ortho_ok_ext.intro
fst_l_ortho_ok_ext.axioms
*)

snd_l_ortho.intro
(*snd_l_ortho.axioms*)
snd_l_ortho.ax

snd_l_ortho_base_ext.intro
(*snd_l_ortho_base_ext.axioms*)
snd_l_ortho_base_ext.ax
(*
snd_l_ortho_ok_ext.intro
snd_l_ortho_ok_ext.axioms
*)

fst_l_snd_l_ortho.intro
(*fst_l_snd_l_ortho.axioms*)
fst_l_snd_l_ortho.ax
fst_l_snd_l_ortho.ax_comm

fst_l_snd_l_ortho_base_ext.intro
(*fst_l_snd_l_ortho_base_ext.axioms*)
fst_l_snd_l_ortho_base_ext.ax
fst_l_snd_l_ortho_base_ext.ax_comm

(*
fst_l_snd_l_ortho_ok_ext.intro
fst_l_snd_l_ortho_ok_ext.axioms
*)

merge_l_ortho.intro
(*merge_l_ortho.axioms*)
(* might wish to use ax_g' instead? *)
(*merge_l_ortho.ax_g
merge_l_ortho.ax_g_comm*)
(* as with merge lifting validity, using the _g version here
 * seems to cause divergence in the automation 
 * probably to do with the use of set intersection
 * hopefully this isn't a problem, or we can find some
 * simplification or other rule to eliminate.
 *)
merge_l_ortho.ax
merge_l_ortho.ax_comm

merge_l_ortho_base_ext.intro
(*merge_l_ortho_base_ext.axioms*)
merge_l_ortho_base_ext.ax
merge_l_ortho_base_ext.ax_comm
(*
merge_l_ortho_ok_ext.intro
merge_l_ortho_ok_ext.axioms
*)

(* typeclass instance definitions *)
lemmas bogus_defs =
  md_triv_bogus
  option_bogus
  md_prio_bogus
  prod_bogus

lemmas pleq_defs =
  triv_pleq
  option_pleq
  prio_pleq
  prod_pleq

lemmas bsup_defs =
  triv_bsup
  option_bsup
  prio_bsup
  prod_bsup

lemmas ok_S_defs =
  triv_ok_S
  option_ok_S
  prio_ok_S
  prod_ok_S

(* lifting instance definitions *)
lemmas lifter_instances =
  triv_l_def
  option_l_def
  prio_l_def
  fst_l_def
  snd_l_def
  id_l_def
  merge_l_def

lemmas lifter_S_instances =
  option_l_S_def
  prio_l_S_def
  fst_l_S_def
  snd_l_S_def

end