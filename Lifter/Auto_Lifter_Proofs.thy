theory Auto_Lifter_Proofs
  imports Lifter Lifter_Instances Auto_Lifter "Velocity/Schem_Lift_Defs"
begin

(* 
 * In this file, we have some rather basic proof automation (really just lemma-lists to supply
 * to Isabelle's automation) to support reasoning about the output of the schem_lift automation
 * (see Auto_Lifter.thy) without having to manually unfold definitions and dig into the
 * details of what that lifting is actually doing.
 *
 * This file (currently) supports proving
 * various notions of validity (see Lifter.thy) for the liftings 
 * generated by the auto lifter. This tends to be straightforward since the auto lifter
 * is really just composing liftings already known to be valid. However, sometimes the
 * lifting transformers involved have nontrivial side-conditions, which can make the proof
 * more difficult. We aim to at least handle the easy cases effortlessly.
 *
 * One common case where the proof can become a bit more challenging but should still be
 * relatively easy to automate is when the side-condition stipulates that a pair of liftings
 * needs to be orthogonal in order for the lifting to be valid. Such cases can also be automatable
 * if the orthogonality falls directly out of the structure of the liftings involved
 * (e.g. when merging fst_l and snd_l, orthogonality is trivial)
 *)

(* TODO: automation for orthogonality, sups_pres, etc. (side-conditions on when merging
 * two or more semantics is well defined) *)

(* vsg versions add a side condition on equality of the valid set,
   which might make them more useful. *)

(* lemmas for showing base is bot *)
(*
lemma option_l_base_bot :
  shows "LBase (option_l l) s = \<bottom>"
  by(auto simp add: option_l_def option_bot)

lemma prio_l_base_bot :
  assumes H : "LBase l s = \<bottom>"
  shows "LBase (prio_l (\<lambda> _ . 0) f1 l) s = \<bottom>"
  using assms
  by(auto simp add: prio_l_def prio_bot)

lemma fst_l_base_bot :
  assumes H : "LBase l1 s = \<bottom>"
  shows "LBase (fst_l l1) s = \<bottom>"
  using assms
  by(auto simp add: fst_l_def prod_bot)

lemma snd_l_base_bot :
  assumes H : "LBase l1 s = \<bottom>"
  shows "LBase (snd_l l1) s = \<bottom>"
  using assms
  by(auto simp add: snd_l_def prod_bot)

lemma merge_l_base_bot :
  assumes H : "LBase l1 s = \<bottom>"
  shows "LBase (merge_l l1 l2) s = \<bottom>"
  using assms
  by(auto simp add: merge_l_def)


(* TODO: if performance is good, add this to our simplification sets *)
lemmas base_bot =
  option_l_base_bot
  prio_l_base_bot
fst_l_base_bot
snd_l_base_bot
merge_l_base_bot
*)

lemmas lifting_defs =
  prio_l_inc_def
  prio_l_inc2_def
  prio_l_incN_def
  prio_l_case_inc_def

(* definitions for breaking up compound locales
 * useful with "fastforce intros..." and similar *)
lemmas lifting_valid_locale_intro = 
  lifting_valid.intro
  lifting_valid_weak_base.intro
  lifting_valid_base.intro
  lifting_valid_weak_ok.intro
  lifting_valid_ok.intro
  lifting_valid_weak_base_ok.intro
  lifting_valid_base_ok.intro
  lifting_valid_weak_pres.intro
  lifting_valid_pres.intro
  lifting_valid_weak_base_pres.intro
  lifting_valid_base_pres.intro
  lifting_valid_weak_ok_pres.intro
  lifting_valid_ok_pres.intro
  lifting_valid_weak_base_ok_pres.intro
  lifting_valid_base_ok_pres.intro
  lifting_valid_weak_pairwise.intro
  lifting_valid_pairwise.intro
  lifting_valid_weak_base_pairwise.intro
  lifting_valid_base_pairwise.intro
  lifting_valid_weak_ok_pairwise.intro
  lifting_valid_ok_pairwise.intro
  lifting_valid_weak_base_ok_pairwise.intro
  lifting_valid_base_ok_pairwise.intro
  lifting_valid_weak_pres_pairwise.intro
  lifting_valid_pres_pairwise.intro
  lifting_valid_weak_base_pres_pairwise.intro
  lifting_valid_base_pres_pairwise.intro
  lifting_valid_weak_ok_pres_pairwise.intro
  lifting_valid_ok_pres_pairwise.intro
  lifting_valid_weak_base_ok_pres_pairwise.intro
  lifting_valid_base_ok_pres_pairwise.intro

(* definitions for breaking up compound locales above the line
 * useful with "fastforce dest..." and similar *)
lemmas lifting_valid_locale_axioms = 
  lifting_valid.axioms
  lifting_valid_weak_base.axioms
  lifting_valid_base.axioms
  lifting_valid_weak_ok.axioms
  lifting_valid_ok.axioms
  lifting_valid_weak_base_ok.axioms
  lifting_valid_base_ok.axioms
  lifting_valid_weak_pres.axioms
  lifting_valid_pres.axioms
  lifting_valid_weak_base_pres.axioms
  lifting_valid_base_pres.axioms
  lifting_valid_weak_ok_pres.axioms
  lifting_valid_ok_pres.axioms
  lifting_valid_weak_base_ok_pres.axioms
  lifting_valid_base_ok_pres.axioms
  lifting_valid_weak_pairwise.axioms
  lifting_valid_pairwise.axioms
  lifting_valid_weak_base_pairwise.axioms
  lifting_valid_base_pairwise.axioms
  lifting_valid_weak_ok_pairwise.axioms
  lifting_valid_ok_pairwise.axioms
  lifting_valid_weak_base_ok_pairwise.axioms
  lifting_valid_base_ok_pairwise.axioms
  lifting_valid_weak_pres_pairwise.axioms
  lifting_valid_pres_pairwise.axioms
  lifting_valid_weak_base_pres_pairwise.axioms
  lifting_valid_base_pres_pairwise.axioms
  lifting_valid_weak_ok_pres_pairwise.axioms
  lifting_valid_ok_pres_pairwise.axioms
  lifting_valid_weak_base_ok_pres_pairwise.axioms
  lifting_valid_base_ok_pres_pairwise.axioms

(* TODO: do we need putonly instances? *)
(* TODO: do we need ax or just ax_g? *)

(* to build up our lemmas list, we first include some rules we pretty much always want. *)
lemmas lifting_valid_basic =
lifting_valid_locale_intro 
(*
  id_l.lifting_putonly_axioms
  id_l.lifting_valid_weak_axioms
*)

  triv_l_valid_oc_ext.ax

(*
  triv_l.lifting_putonly_axioms
  triv_l.lifting_valid_weak_axioms
  triv_l.lifting_valid_pres_ext_axioms
  triv_l.lifting_valid_ok_ext_axioms
  triv_l.lifting_valid_pairwise_ext_axioms
*)

  

  option_l_valid_weak.intro

  option_l_valid_ext.intro
  option_l_valid_ext.ax

  option_l_valid_base_ext.ax

  option_l_valid_ok_ext.intro

  option_l_valid_pres_ext.intro

  option_l_valid_base_pres_ext.intro

  option_l_valid_pairwise_ext.intro


  prio_l_valid_weak.intro
prio_l_valid_weak'.intro

(* TODO: double check these w/r/t stronger. *)
prio_l_valid_ext_strong.intro
prio_l_valid_ext_strong.ax
prio_l_valid_ext_strong'.intro

prio_l_valid_base_ext.intro
prio_l_valid_base_ext.ax
prio_l_valid_base'.intro

prio_l_valid_ok_ext.intro

prio_l_valid_base_ok_pres.intro

prio_l_valid_pairwise_ext.intro

  fst_l_valid_weak.intro

  fst_l_valid_ext.intro
fst_l_valid_ext.ax

  fst_l_valid_base_ext.intro
fst_l_valid_base_ext.ax

fst_l_valid_ok_ext.intro
fst_l_valid_ok_ext.ax

fst_l_valid_pres_ext.intro

fst_l_valid_base_pres_ext.intro

  snd_l_valid_weak.intro

  snd_l_valid_ext.intro
snd_l_valid_ext.ax

  snd_l_valid_base_ext.intro
snd_l_valid_base_ext.ax

snd_l_valid_ok_ext.intro
snd_l_valid_ok_ext.ax

snd_l_valid_pres_ext.intro

snd_l_valid_base_pres_ext.intro

merge_l_valid_weak.intro

merge_l_valid_ext.intro
merge_l_valid_ext.ax

merge_l_valid_base_ext.intro
merge_l_valid_base_ext.ax

merge_l_valid_ok_ext.intro

(* NB: don't have pres proofs for merge (likely not true in general) *)

merge_l_valid_pairwise_ext.intro

(* next we add in variants of lemmas that do not abstract the valid-set.
 * this makes the automation behavior more predictable, but may not be able
 * to solve more complex validity structures (e.g. merge liftings).
 *)
lemmas lifting_valid_fast =
  lifting_valid_basic 

  triv_l_valid_weak.ax
  triv_l_valid_ok_ext.ax
  triv_l_valid_pres_ext.ax
  triv_l_valid_ok_ext.ax

  option_l_valid_weak.ax
  option_l_valid_ok_ext.ax
  option_l_valid_pres_ext.ax
  option_l_valid_base_pres_ext.ax
  option_l_valid_pairwise_ext.ax

  prio_l_valid_weak.ax
  prio_l_valid_ok_ext.ax
  prio_l_valid_base_ok_pres.ax
  prio_l_valid_pairwise_ext.ax
  
  fst_l_valid_weak.ax
  fst_l_valid_pres_ext.ax
  fst_l_valid_base_pres_ext.ax
  
  snd_l_valid_weak.ax
  snd_l_valid_pres_ext.ax
  snd_l_valid_base_pres_ext.ax
  
  merge_l_valid_ok_ext.ax
  merge_l_valid_pairwise_ext.ax
  merge_l_valid_weak.ax


lemmas lifting_valid_standard_no_merge =
lifting_valid_basic

  triv_l_valid_weak.ax_g
  triv_l_valid_ok_ext.ax_g
  triv_l_valid_pres_ext.ax_g
  triv_l_valid_ok_ext.ax_g


  option_l_valid_weak.ax_g
  option_l_valid_ok_ext.ax_g
  option_l_valid_pres_ext.ax_g
  option_l_valid_base_pres_ext.ax_g
  option_l_valid_pairwise_ext.ax_g

  prio_l_valid_weak.ax_g
prio_l_valid_ok_ext.ax_g
prio_l_valid_base_ok_pres.ax_g
prio_l_valid_pairwise_ext.ax_g

fst_l_valid_weak.ax_g
fst_l_valid_pres_ext.ax_g
fst_l_valid_base_pres_ext.ax_g

snd_l_valid_weak.ax_g
snd_l_valid_pres_ext.ax_g
snd_l_valid_base_pres_ext.ax_g

merge_l_valid_ok_ext.ax_g
merge_l_valid_pairwise_ext.ax_g

(* a decent default setting for automation, but a bit on the conservative side speed wise *)
lemmas lifting_valid_standard =
  lifting_valid_standard_no_merge
  merge_l_valid_weak.ax

(* Next, a variant that has the slower version of merge_l *)
lemmas lifting_valid_slow =
  lifting_valid_standard_no_merge
  merge_l_valid_weak.ax_g

(* finally, a variant that also adds the "strong" version of prio_l
 * (TODO: make sure we don't also need to remove the standard version of prio_l from the list)
 *)
lemmas lifting_valid_slower =
  lifting_valid_slow
 
prio_l_valid_ext_stronger.intro
prio_l_valid_ext_stronger.ax_g

prio_l_valid_ext_stronger_ok.intro
prio_l_valid_ext_stronger_ok.ax_g

prio_l_valid_ext_stronger'.intro


lemmas lifting_valid_set_defs =
  option_l_S_def
  prio_l_S_def
  fst_l_S_def
  snd_l_S_def

lemmas lifting_ortho_locale_intro =
  l_ortho_pres.intro
l_ortho_base.intro
l_ortho_base_pres.intro
l_ortho_ok.intro
l_ortho_ok_pres.intro
l_ortho_base_ok_pres.intro

(* TODO: we currently don't separate out the set-abstracting orthogonality lemmas.
 * this might be something to try.*)
lemmas lifting_ortho_basic =

lifting_ortho_locale_intro

  option_l_ortho.intro

option_l_ortho_base_ext.intro
option_l_ortho_base_ext.ax

option_l_ortho_ok_ext.intro

fst_l_ortho.intro

fst_l_ortho_base_ext.intro
fst_l_ortho_base_ext.ax

snd_l_ortho.intro

snd_l_ortho_base_ext.intro
snd_l_ortho_base_ext.ax

fst_l_snd_l_ortho.intro

fst_l_snd_l_ortho_base_ext.intro

merge_l_ortho.intro

merge_l_ortho_base_ext.intro
merge_l_ortho_base_ext.ax
merge_l_ortho_base_ext.ax_comm

lemmas lifting_ortho_fast =
  lifting_ortho_basic

option_l_ortho.ax
fst_l_ortho.ax
snd_l_ortho.ax
fst_l_snd_l_ortho.ax
fst_l_snd_l_ortho.ax_comm

merge_l_ortho.ax
merge_l_ortho.ax_comm


lemmas lifting_ortho_standard_no_merge = 
lifting_ortho_basic
option_l_ortho.ax_g
fst_l_ortho.ax_g
snd_l_ortho.ax_g
fst_l_snd_l_ortho.ax_g
fst_l_snd_l_ortho.ax_g_comm


lemmas lifting_ortho_standard =
lifting_ortho_standard_no_merge
merge_l_ortho.ax
merge_l_ortho.ax_comm

lemmas lifting_ortho_slow =
  lifting_ortho_standard_no_merge
  merge_l_ortho.ax_g
  merge_l_ortho.ax_g_comm

(* typeclass instance definitions *)
lemmas bogus_defs =
  md_triv_bogus
  option_bogus
  md_prio_bogus
  prod_bogus

lemmas pleq_defs =
  triv_pleq
  option_pleq
  prio_pleq
  prod_pleq

lemmas bsup_defs =
  triv_bsup
  option_bsup
  prio_bsup
  prod_bsup

lemmas ok_S_defs =
  triv_ok_S
  option_ok_S
  prio_ok_S
  prod_ok_S

lemmas bot_defs =
  option_bot
  prio_bot
  prod_bot


(* lifting instance definitions *)
lemmas lifter_instances =
  triv_l_def
  option_l_def
  prio_l_def
  fst_l_def
  snd_l_def
  id_l_def
  merge_l_def

lemmas lifter_S_instances =
  option_l_S_def
  prio_l_S_def
  fst_l_S_def
  snd_l_S_def

end