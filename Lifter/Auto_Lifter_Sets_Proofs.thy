theory Auto_Lifter_Sets_Proofs
imports Lifter Lifter_Instances Auto_Lifter_Sets Auto_Lifter_Proofs
begin

(* 
 * In this file, we have some rather basic proof automation (really just lemma-lists to supply
 * to Isabelle's automation) to support reasoning about the output of the schem_lift automation
 * (see Auto_Lifter.thy) without having to manually unfold definitions and dig into the
 * details of what that lifting is actually doing.
 *
 * This file (currently) supports proving
 * various notions of validity (see Lifter.thy) for the liftings 
 * generated by the auto lifter. This tends to be straightforward since the auto lifter
 * is really just composing liftings already known to be valid. However, sometimes the
 * lifting transformers involved have nontrivial side-conditions, which can make the proof
 * more difficult. We aim to at least handle the easy cases effortlessly.
 *
 * One common case where the proof can become a bit more challenging but should still be
 * relatively easy to automate is when the side-condition stipulates that a pair of liftings
 * needs to be orthogonal in order for the lifting to be valid. Such cases can also be automatable
 * if the orthogonality falls directly out of the structure of the liftings involved
 * (e.g. when merging fst_l and snd_l, orthogonality is trivial)
 *)

(* TODO: automation for orthogonality, sups_pres, etc. (side-conditions on when merging
 * two or more semantics is well defined) *)

(* vsg versions add a side condition on equality of the valid set,
   which might make them more useful. *)



lemma schem_lift_S_base_idA_alt :
  "(schem_lift_S NA NA) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idA_def)
lemma schem_lift_S_base_idB_alt :
  "(schem_lift_S NB NB) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idB_def)
lemma schem_lift_S_base_idC_alt :
  "(schem_lift_S NC NC) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idC_def)
lemma schem_lift_S_base_idD_alt :
  "(schem_lift_S ND ND) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idD_def)
lemma schem_lift_S_base_idE_alt :
  "(schem_lift_S NE NE) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idE_def)
lemma schem_lift_S_base_idF_alt :
  "(schem_lift_S NF NF) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idF_def)
lemma schem_lift_S_base_idG_alt :
  "(schem_lift_S NG NG) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idG_def)
lemma schem_lift_S_base_idH_alt :
  "(schem_lift_S NH NH) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idH_def)
lemma schem_lift_S_base_idI_alt :
  "(schem_lift_S NI NI) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idI_def)
lemma schem_lift_S_base_idJ_alt :
  "(schem_lift_S NJ NJ) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idJ_def)
lemma schem_lift_S_base_idK_alt :
  "(schem_lift_S NK NK) = (\<lambda> _ . UNIV)"
  by(rule ext; auto simp add: schem_lift_S_base_idK_def)

lemmas schem_lift_S_defs =
  schem_lift_S_base_idA_alt
  schem_lift_S_base_idB_alt
  schem_lift_S_base_idC_alt
  schem_lift_S_base_idD_alt
  schem_lift_S_base_idE_alt

  schem_lift_S_option_recR_def
  schem_lift_S_prio_recR_def
  schem_lift_S_oalist_recR_def

  schem_lift_S_prod_recR_A_left_def
  schem_lift_S_prod_recR_A_right_def
  schem_lift_S_prod_recR_B_left_def
  schem_lift_S_prod_recR_B_right_def
  schem_lift_S_prod_recR_C_left_def
  schem_lift_S_prod_recR_C_right_def
  schem_lift_S_prod_recR_D_left_def
  schem_lift_S_prod_recR_D_right_def
  schem_lift_S_prod_recR_E_left_def
  schem_lift_S_prod_recR_E_right_def

  schem_lift_S_merge_recR_A_left_def
  schem_lift_S_merge_recR_A_right_def
  schem_lift_S_merge_recR_B_left_def
  schem_lift_S_merge_recR_B_right_def
  schem_lift_S_merge_recR_C_left_def
  schem_lift_S_merge_recR_C_right_def
  schem_lift_S_merge_recR_D_left_def
  schem_lift_S_merge_recR_D_right_def
  schem_lift_S_merge_recR_E_left_def
  schem_lift_S_merge_recR_E_right_def

  schem_lift_S_recL_def


(* test *)
lemma lift_test :



  shows "lifting_validb (schem_lift (SP NA NB) (SP (SPRI (SO NA)) (SPRI (SO NB))))
                       (schem_lift_S (SP NA NB) (SP (SPRI (SO NA)) (SPRI (SO NB))))"
by(fastforce simp add: schem_lift_defs schem_lift_S_defs
intro: lifting_valid_vsg lifting_ortho_alt
)


end