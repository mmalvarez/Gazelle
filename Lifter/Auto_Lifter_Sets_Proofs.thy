theory Auto_Lifter_Sets_Proofs
imports Lifter Lifter_Instances Auto_Lifter_Sets Auto_Lifter_Proofs
begin

(* 
 * In this file, we have some rather basic proof automation (really just lemma-lists to supply
 * to Isabelle's automation) to support reasoning about the output of the schem_lift automation
 * (see Auto_Lifter.thy) without having to manually unfold definitions and dig into the
 * details of what that lifting is actually doing.
 *
 * This file (currently) supports proving
 * various notions of validity (see Lifter.thy) for the liftings 
 * generated by the auto lifter. This tends to be straightforward since the auto lifter
 * is really just composing liftings already known to be valid. However, sometimes the
 * lifting transformers involved have nontrivial side-conditions, which can make the proof
 * more difficult. We aim to at least handle the easy cases effortlessly.
 *
 * One common case where the proof can become a bit more challenging but should still be
 * relatively easy to automate is when the side-condition stipulates that a pair of liftings
 * needs to be orthogonal in order for the lifting to be valid. Such cases can also be automatable
 * if the orthogonality falls directly out of the structure of the liftings involved
 * (e.g. when merging fst_l and snd_l, orthogonality is trivial)
 *)

(* TODO: automation for orthogonality, sups_pres, etc. (side-conditions on when merging
 * two or more semantics is well defined) *)

(* vsg versions add a side condition on equality of the valid set,
   which might make them more useful. *)

lemmas schem_lift_S_defs =
  schem_lift_S_base_idA_def
  schem_lift_S_base_idB_def
  schem_lift_S_base_idC_def
  schem_lift_S_base_idD_def
  schem_lift_S_base_idE_def

  schem_lift_S_option_recR_def
  schem_lift_S_prio_recR_def
  schem_lift_S_oalist_recR_def

  schem_lift_S_prod_recR_A_left_def
  schem_lift_S_prod_recR_A_right_def
  schem_lift_S_prod_recR_B_left_def
  schem_lift_S_prod_recR_B_right_def
  schem_lift_S_prod_recR_C_left_def
  schem_lift_S_prod_recR_C_right_def
  schem_lift_S_prod_recR_D_left_def
  schem_lift_S_prod_recR_D_right_def
  schem_lift_S_prod_recR_E_left_def
  schem_lift_S_prod_recR_E_right_def

  schem_lift_S_merge_recR_A_left_def
  schem_lift_S_merge_recR_A_right_def
  schem_lift_S_merge_recR_B_left_def
  schem_lift_S_merge_recR_B_right_def
  schem_lift_S_merge_recR_C_left_def
  schem_lift_S_merge_recR_C_right_def
  schem_lift_S_merge_recR_D_left_def
  schem_lift_S_merge_recR_D_right_def
  schem_lift_S_merge_recR_E_left_def
  schem_lift_S_merge_recR_E_right_def

  schem_lift_S_recL_def


(* test *)

(* need validb for merge_l *)

lemma lift_test :
  shows "lifting_validb (schem_lift (SP NA NB) (SP (SPRI (SO NA)) (SPRI (SO NB))))
                       (schem_lift_S (SP NA NB) (SP (SPRI (SO NA)) (SPRI (SO NB))))"
  apply(auto simp add: schem_lift_defs schem_lift_S_defs lifting_valid_set_defs
intro: lifting_valid_vsg
)
  apply(rule merge_l_validb)
  apply(auto simp add: schem_lift_defs schem_lift_S_defs lifting_valid_set_defs
intro: lifting_valid_vsg'
)
    apply(rule fst_l_validb) apply(rule prio_l_validb_stronger)
       apply(rule option_l_valid_weakb)
  apply(rule triv_l_valid_weak)
       apply(simp add: prio_l_S_def option_l_S_def schem_lift_S_defs)
      apply(auto)

  apply(case_tac xa; auto)
    apply(simp add: schem_lift_S_defs option_l_S_def)
(* TODO: figure out how to deal with fst vs. snd... *)
(* probably we need to relax merge_l_validb... *)
   apply(rule snd_l_validb_vsg)
    defer
    apply(rule prio_l_validb_stronger)
      apply(rule option_l_valid_weakb)
       apply(rule triv_l_valid_weak)
      apply(rule subset_refl)
     apply(simp)
  apply(simp)
   defer

  apply(rule ext)
   apply(auto simp add: fst_l_S_def snd_l_S_def prio_l_S_def option_l_S_def schem_lift_S_defs
split: md_prio.splits)

       defer
       apply(rule option_l_valid_weakb)
       apply(rule triv_l_valid_weak)
  apply(auto)
  apply(auto simp add: prio_l_S_def option_l_S_def schem_lift_S_defs split: md_prio.splits)

    apply(auto intro: fst_l_valid prio_l_valid option_l_valid)

    apply(rule prio_l_validb_strong_vsg)
     apply(rule option_l_validb)
  apply(rule triv_l_valid)
  apply(rule )


(* lifting_valid? *)


end