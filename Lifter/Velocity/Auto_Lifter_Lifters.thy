theory Auto_Lifter_Lifters
    imports Main "../Auto_Lifter_Datatypes" "../../Mergeable/Mergeable" "../Lifter_Instances" 
      "HOL-Library.Adhoc_Overloading"
begin

(* This file implements some (extremely hacky) automation for generating Liftings
 * based on a user-supplied specification. The specification is somewhat more convenient
 * than actually writing out the liftings in full: essentially the user describes a
 * "schema" of names for the "small" type being lifted, and then how those names map into fields of
 * the "larger" type into which it is being lifted.
 *
 * Perhaps surprisingly (given the limitations of Isabelle's typeclass system), we are able
 * to accomplish this translation by (ab)using Isabelle's built-in infrastructure for
 * typeclasses and ad-hoc polymorphism.
 *
 * A rather hand-wavey intuition for how this works is the following:
 * Inference for ad-hoc constants cannot backtrack; at each point during inference,
 * we must be able to pick a direction and have certainty that either we will find a valid
 * instance or fail. Ambiguity (i.e., overlapping instances) at any point will cause a failure.
 * In our case, this happens for instance when descending into a tuple. If we are looking for an
 * instance of the name 'A' in the tuple, we need to be able to know immediately if 'A' is to
 * be found in the first or second component of the tuple, to avoid backtracking.
 *
 * What saves us is that ad-hoc constant inference can be guarded by typeclass constraints,
 * and these constraints can disambiguate what would otherwise be overlapping instances.
 * In our case, if we are able to infer that the first component of the tuple inhabits the
 * "hasntA" typeclass, we can proceed recursively on the second component, without fear
 * of overlaps. In order to make this work, we restrict schema to use a "closed universe"
 * of pre-defined names (though this universe is quite easy to extend; see below).
 *
 * The fact that this all works still feels somewhat magical. Of course, the downside to
 * pushing the limits of the typeclass and ad-hoc polymorphism capabilities of Isabelle
 * is that error-messages are nearly unintelligible.
 *
 * There is some corresponding proof automation for reasoning about liftings generated by
 * the automation here (really just hint sets, nothing too exotic). That automation is in
 * Auto_Lifter_Proofs.thy
 *)


(* We support a limited (but extensible) set of names. *)
(* Each name Z needs the following to be added to the auto-lifter:
   - class n_Z
   - datatype nZ, instantiated at n_Z, basename, and schem
   - a class hasntZ
   - an instantiation of hasntZ for type constructors (i.e., prod, md_prio, etc.)
   - an instantiation of hasntZ for _all_ base-names that are not z
     - yes, this leads to a polynomial number of instance declarations.
   - instances of schem_lift: schem_lift_base_trivZ and schem_lift_base_idZ
     - these must be defined (see e.g. schem_lift_trivA, below), then added to the
       listing of overloaded instances for schem_lift at the end of the file
*)

(* Each name N gets a class n_N *)



class n_A
class n_B
class n_C
class n_D
class n_E
class n_F
class n_G
class n_H
class n_I
class n_J
class n_K

(* Class collecting all "base" names. We could perhaps use this more aggressively
 * to clean up some of the inference code *)
class basename


(* each name N gets a dummy datatype NN *)

datatype nA = NA
datatype nB = NB
datatype nC = NC
datatype nD = ND
datatype nE = NE
datatype nF = NF
datatype nG = NG
datatype nH = NH
datatype nI = NI
datatype nJ = NJ
datatype nK = NK

datatype nX = NX

instantiation nA :: n_A begin
instance proof qed
end

instantiation nA :: basename begin
instance proof qed
end

instantiation nB :: n_B begin
instance proof qed
end

instantiation nB :: basename begin
instance proof qed
end

instantiation nC :: n_C begin
instance proof qed
end

instantiation nC :: basename begin
instance proof qed
end

instantiation nD :: n_D begin
instance proof qed
end

instantiation nD :: basename begin
instance proof qed
end

instantiation nE :: n_E begin
instance proof qed
end

instantiation nE :: basename begin
instance proof qed
end

instantiation nF :: n_F begin
instance proof qed
end

instantiation nF :: basename begin
instance proof qed
end

instantiation nG :: n_G begin
instance proof qed
end

instantiation nG :: basename begin
instance proof qed
end

instantiation nH :: n_H begin
instance proof qed
end

instantiation nH :: basename begin
instance proof qed
end

instantiation nI :: n_I begin
instance proof qed
end

instantiation nI :: basename begin
instance proof qed
end

instantiation nJ :: n_J begin
instance proof qed
end

instantiation nJ :: basename begin
instance proof qed
end

instantiation nK :: n_K begin
instance proof qed
end

instantiation nK :: basename begin
instance proof qed
end


(* schem is going to include both names (fields) as well as compound structures *)
class schem

instantiation nA :: schem begin
instance proof qed
end

instantiation nB :: schem begin
instance proof qed
end

instantiation nC :: schem begin
instance proof qed
end

instantiation nD :: schem begin
instance proof qed
end

instantiation nE :: schem begin
instance proof qed
end

instantiation nF :: schem begin
instance proof qed
end

instantiation nG :: schem begin
instance proof qed
end

instantiation nH :: schem begin
instance proof qed
end

instantiation nI :: schem begin
instance proof qed
end

instantiation nJ :: schem begin
instance proof qed
end

instantiation nK :: schem begin
instance proof qed
end


instantiation nX :: schem begin
instance proof qed
end

instantiation sprod :: (schem, schem) schem begin
instance proof qed
end

instantiation sprio :: (_, schem) schem begin
instance proof qed
end

instantiation soption :: (schem) schem begin
instance proof qed
end

instantiation soalist :: (_, linorder, schem) schem begin
instance proof qed
end

instantiation sroalist :: (_, linorder, schem) schem begin
instance proof qed
end

instantiation smerge :: (schem, schem) schem begin
instance proof qed
end

instantiation sfan :: (_, _, _, schem) schem begin
instance proof qed
end

instantiation sinject :: (_ , _, _, schem) schem
begin
instance proof qed
end

instantiation sid :: (schem) schem
begin
instance proof qed
end


class hasntA
class hasntB
class hasntC
class hasntD
class hasntE
class hasntF
class hasntG
class hasntH
class hasntI
class hasntJ
class hasntK

instantiation nA :: "{
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nB :: "{
hasntA,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nC :: "{
hasntA,
hasntB,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nD :: "{
hasntA,
hasntB,
hasntC,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nE :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nF :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nG :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nH :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nI :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end

instantiation nJ :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntK,
type}"
begin
instance proof qed
end

instantiation nK :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
type}"
begin
instance proof qed
end



(* By convention, we use X to denote names we don't care about (think "_" in pattern-match).
 * For this reason we do not need a "hasntX" typeclass - we will never be searching _for_ X. *)
instantiation nX :: "{
hasntA,
hasntB,
hasntC,
hasntD,
hasntE,
hasntF,
hasntG,
hasntH,
hasntI,
hasntJ,
hasntK,
type}"
begin
instance proof qed
end


instantiation sprod :: (hasntA, hasntA) hasntA begin
instance proof qed
end
instantiation sprod :: (hasntB, hasntB) hasntB begin
instance proof qed
end
instantiation sprod :: (hasntC, hasntC) hasntC begin
instance proof qed
end
instantiation sprod :: (hasntD, hasntD) hasntD begin
instance proof qed
end
instantiation sprod :: (hasntE, hasntE) hasntE begin
instance proof qed
end
instantiation sprod :: (hasntF, hasntF) hasntF begin
instance proof qed
end
instantiation sprod :: (hasntG, hasntG) hasntG begin
instance proof qed
end
instantiation sprod :: (hasntH, hasntH) hasntH begin
instance proof qed
end
instantiation sprod :: (hasntI, hasntI) hasntI begin
instance proof qed
end
instantiation sprod :: (hasntJ, hasntJ) hasntJ begin
instance proof qed
end
instantiation sprod :: (hasntK, hasntK) hasntK begin
instance proof qed
end

instantiation sprio :: (_, hasntA) hasntA begin
instance proof qed
end
instantiation sprio :: (_, hasntB) hasntB begin
instance proof qed
end
instantiation sprio :: (_, hasntC) hasntC begin
instance proof qed
end
instantiation sprio :: (_, hasntD) hasntD begin
instance proof qed
end
instantiation sprio :: (_, hasntE) hasntE begin
instance proof qed
end
instantiation sprio :: (_, hasntF) hasntF begin
instance proof qed
end
instantiation sprio :: (_, hasntG) hasntG begin
instance proof qed
end
instantiation sprio :: (_, hasntH) hasntH begin
instance proof qed
end
instantiation sprio :: (_, hasntI) hasntI begin
instance proof qed
end
instantiation sprio :: (_, hasntJ) hasntJ begin
instance proof qed
end
instantiation sprio :: (_, hasntK) hasntK begin
instance proof qed
end

instantiation soption :: (hasntA) hasntA begin
instance proof qed
end
instantiation soption :: (hasntB) hasntB begin
instance proof qed
end
instantiation soption :: (hasntC) hasntC begin
instance proof qed
end
instantiation soption :: (hasntD) hasntD begin
instance proof qed
end
instantiation soption :: (hasntE) hasntE begin
instance proof qed
end
instantiation soption :: (hasntF) hasntF begin
instance proof qed
end
instantiation soption :: (hasntG) hasntG begin
instance proof qed
end
instantiation soption :: (hasntH) hasntH begin
instance proof qed
end
instantiation soption :: (hasntI) hasntI begin
instance proof qed
end
instantiation soption :: (hasntJ) hasntJ begin
instance proof qed
end
instantiation soption :: (hasntK) hasntK begin
instance proof qed
end

instantiation soalist :: (_, linorder, hasntA) hasntA begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntB) hasntB begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntC) hasntC begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntD) hasntD begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntE) hasntE begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntF) hasntF begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntG) hasntG begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntH) hasntH begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntI) hasntI begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntJ) hasntJ begin
instance proof qed
end
instantiation soalist :: (_, linorder, hasntK) hasntK begin
instance proof qed
end

instantiation sroalist :: (_, linorder, hasntA) hasntA begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntB) hasntB begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntC) hasntC begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntD) hasntD begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntE) hasntE begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntF) hasntF begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntG) hasntG begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntH) hasntH begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntI) hasntI begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntJ) hasntJ begin
instance proof qed
end
instantiation sroalist :: (_, linorder, hasntK) hasntK begin
instance proof qed
end

instantiation smerge :: (hasntA, hasntA) hasntA begin
instance proof qed
end
instantiation smerge :: (hasntB, hasntB) hasntB begin
instance proof qed
end
instantiation smerge :: (hasntC, hasntC) hasntC begin
instance proof qed
end
instantiation smerge :: (hasntD, hasntD) hasntD begin
instance proof qed
end
instantiation smerge :: (hasntE, hasntE) hasntE begin
instance proof qed
end
instantiation smerge :: (hasntF, hasntF) hasntF begin
instance proof qed
end
instantiation smerge :: (hasntG, hasntG) hasntG begin
instance proof qed
end
instantiation smerge :: (hasntH, hasntH) hasntH begin
instance proof qed
end
instantiation smerge :: (hasntI, hasntI) hasntI begin
instance proof qed
end
instantiation smerge :: (hasntJ, hasntJ) hasntJ begin
instance proof qed
end
instantiation smerge :: (hasntK, hasntK) hasntK begin
instance proof qed
end

instantiation sfan :: (_, _, _, hasntA) hasntA begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntB) hasntB begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntC) hasntC begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntD) hasntD begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntE) hasntE begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntF) hasntF begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntG) hasntG begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntH) hasntH begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntI) hasntI begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntJ) hasntJ begin
instance proof qed
end
instantiation sfan :: (_, _, _, hasntK) hasntK begin
instance proof qed
end

instantiation sinject :: (_, _, _, hasntA) hasntA begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntB) hasntB begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntC) hasntC begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntD) hasntD begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntE) hasntE begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntF) hasntF begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntG) hasntG begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntH) hasntH begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntI) hasntI begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntJ) hasntJ begin
instance proof qed
end
instantiation sinject :: (_, _, _, hasntK) hasntK begin
instance proof qed
end

instantiation sid :: (hasntA) hasntA begin
instance proof qed
end
instantiation sid :: (hasntB) hasntB begin
instance proof qed
end
instantiation sid :: (hasntC) hasntC begin
instance proof qed
end
instantiation sid :: (hasntD) hasntD begin
instance proof qed
end
instantiation sid :: (hasntE) hasntE begin
instance proof qed
end
instantiation sid :: (hasntF) hasntF begin
instance proof qed
end
instantiation sid :: (hasntG) hasntG begin
instance proof qed
end
instantiation sid :: (hasntH) hasntH begin
instance proof qed
end
instantiation sid :: (hasntI) hasntI begin
instance proof qed
end
instantiation sid :: (hasntJ) hasntJ begin
instance proof qed
end
instantiation sid :: (hasntK) hasntK begin
instance proof qed
end

(* 
 * At this point, we're set up to define a polymorphic constant, schem_lift, that will
 * infer (synthesize, if you like) the correct lifting based on the user's specification.
 * Because this happens at typeclass-instantiation-time, we can only use type-level information
 * when doing this.
 *
 * One notable intricacy here is that most of the instances corresponding to type constructors
 * (e.g. md_prio, prod, ...) are actually _higher-order_: they take (a) lifting(s)
 * corresponding to their contents, and return a lifting for the whole structure.
 * Where do these liftings come from? We "just" infer them in the same way, recursively!
 *
 * Naively we'd want to use the symbol schem_lift inside of its own instance definitions
 * in such cases, but this doesn't work. What we instead have to do looks a bit like
 * what one does when using a fixed-point combinator to encode a recursive function:
 * we define a function that takes as a parameter the recursive instance of itself, which
 * the fixed-point combinator will fill in later. In cases like prod where we have
 * multiple data, we will have one such argument for each call-site (datum). 
 * 
 * I am not fully sure why this trick works; it has something to do with being able to
 * defer the inference of certain constants until it is possible to have enough information
 * to infer it unambiguously.
 *
 * This encoding is a prime culprit in the awfulness of the error messages generated by this
 * contraption :)
 *)

(* Intuitively, the parameters here are (in order):
 * the "left-hand side" schema corresponding to the "small" type
 * the "right-hand side" schema corresponding to the "big" type.
 * This inference feels somewhat like a search, in that for each piece
 * of the left-hand side (of type 's1), we are trying to find a matching piece
 * of the right-hand side (of type 's2) so that we can construct the appropriate
 * lifting.
 *)
type_synonym ('s1, 's2, 'x, 'a, 'b) schem_lift =
"('s1 \<Rightarrow> 's2 \<Rightarrow> ('x, 'a, 'b) lifting)"

consts schem_lift ::
  "('s1 :: schem, 's2 :: schem, 'x, 'a, 'b) schem_lift"


(* TODO: we could probably reduce these by using the basename typeclass.
   not doing this for now in case it is causing a bug. *)


definition schem_lift_base_trivA ::  "('n :: n_A, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivA _ _ =
  triv_l"
definition schem_lift_base_trivB ::  "('n :: n_B, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivB _ _ =
  triv_l"
definition schem_lift_base_trivC ::  "('n :: n_C, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivC _ _ =
  triv_l"
definition schem_lift_base_trivD ::  "('n :: n_D, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivD _ _ =
  triv_l"
definition schem_lift_base_trivE ::  "('n :: n_E, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivE _ _ =
  triv_l"
definition schem_lift_base_trivF ::  "('n :: n_F, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivF _ _ =
  triv_l"
definition schem_lift_base_trivG ::  "('n :: n_G, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivG _ _ =
  triv_l"
definition schem_lift_base_trivH ::  "('n :: n_H, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivH _ _ =
  triv_l"
definition schem_lift_base_trivI ::  "('n :: n_I, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivI _ _ =
  triv_l"
definition schem_lift_base_trivJ ::  "('n :: n_J, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivJ _ _ =
  triv_l"
definition schem_lift_base_trivK ::  "('n :: n_K, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_trivK _ _ =
  triv_l"

definition schem_lift_base_idA ::  "('n :: n_A, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idA _ _ =
  id_l"
definition schem_lift_base_idB ::  "('n :: n_B, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idB _ _ =
  id_l"
definition schem_lift_base_idC ::  "('n :: n_C, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idC _ _ =
  id_l"
definition schem_lift_base_idD ::  "('n :: n_D, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idD _ _ =
  id_l"
definition schem_lift_base_idE ::  "('n :: n_E, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idE _ _ =
  id_l"
definition schem_lift_base_idF ::  "('n :: n_F, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idF _ _ =
  id_l"
definition schem_lift_base_idG ::  "('n :: n_G, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idG _ _ =
  id_l"
definition schem_lift_base_idH ::  "('n :: n_H, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idH _ _ =
  id_l"
definition schem_lift_base_idI ::  "('n :: n_I, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idI _ _ =
  id_l"
definition schem_lift_base_idJ ::  "('n :: n_J, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idJ _ _ =
  id_l"
definition schem_lift_base_idK ::  "('n :: n_K, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_idK _ _ =
  id_l"

(* Now we implement some instances for recursion "on the right side"
 * (that is, in the "big" type of the lifting,
 * or the "target" or "result" type if you prefer; 'b2 in the following code).
 * Other than the need to encode the recursive call as a
 * parameter, this is straightforward for liftings corresponding to type-constructors with
 * one type parameter (most notably, not prod)
 *)

(* right-side recursion (prio) *)
definition schem_lift_prio_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'ls) sprio, 'x, 'a, 'b2 md_prio) schem_lift" where
"schem_lift_prio_recR rec n s =
  (case s of
    SPR f1 f2 s' \<Rightarrow>
      prio_l f1 f2 (rec n s'))"

(* right-side recursion (option) *)
definition schem_lift_option_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, 'ls soption, 'x, 'a, 'b2 option) schem_lift" where
"schem_lift_option_recR rec n s =
  (case s of
    SO s' \<Rightarrow>
      option_l (rec n s'))"

(* not currently using oalist_l *)
(*
(* right-side recursion (oalist) *)
definition schem_lift_oalist_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'k :: linorder, 'ls) soalist, 'x, 'a, ('k, 'b2) oalist) schem_lift" where
"schem_lift_oalist_recR rec n s =
  (case s of
    SL f1 s' \<Rightarrow>
      oalist_l f1 (rec n s'))"
*)

(* not currently using roalist_l *)
(*
(* right-side recursion (roalist) *)
(* NB we don't allow lifting into the "inr" data of the roalist.
   a separate lifting could allow this. *)
definition schem_lift_roalist_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'k :: linorder, 'ls) sroalist, 'x, 'a, ('k, 'b2, 'z :: Pord) roalist) schem_lift" where
"schem_lift_roalist_recR rec n s =
  (case s of
    SRL f1 s' \<Rightarrow>
      roalist_l f1 (rec n s'))"
*)

(* The instances for the product type are where all the funny business above about
 * the "hasnt" typeclasses finally come into play. These typeclass constraints
 * labels) are the crucial ingredient here; if we removed them, we would reach an ambiguity
 * when doing inference on _any_ tuple, which Isabelle will not tolerate.
 *
 * For instance, when trying to find NA in (NA, NB), we would get stuck because even though
 * NA is clearly on the left side, we cannot prove that NA doesn't also show up on the right side.
 * Since NB inhabits the hasntA typeclass, however, we avoid this case and can make progress.
 *
 * Put differently, "meaningless" typeclass constraints, in combination with ad-hoc overloading,
 * can be a surprisingly powerful tool for automation.
 *)

(* right-side recursion (prod) *)


definition schem_lift_prod_recR_A_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_A, ('ls, 'rs :: hasntA) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_A_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_A_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_A, ('ls :: hasntA, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_A_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_B_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_B, ('ls, 'rs :: hasntB) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_B_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_B_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_B, ('ls :: hasntB, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_B_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_C_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_C, ('ls, 'rs :: hasntC) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_C_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_C_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_C, ('ls :: hasntC, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_C_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_D_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_D, ('ls, 'rs :: hasntD) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_D_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_D_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_D, ('ls :: hasntD, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_D_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_E_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_E, ('ls, 'rs :: hasntE) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_E_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_E_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_E, ('ls :: hasntE, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_E_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_F_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_F, ('ls, 'rs :: hasntF) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_F_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_F_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_F, ('ls :: hasntF, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_F_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_G_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_G, ('ls, 'rs :: hasntG) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_G_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_G_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_G, ('ls :: hasntG, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_G_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_H_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_H, ('ls, 'rs :: hasntH) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_H_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_H_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_H, ('ls :: hasntH, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_H_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_I_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_I, ('ls, 'rs :: hasntI) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_I_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_I_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_I, ('ls :: hasntI, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_I_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_J_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_J, ('ls, 'rs :: hasntJ) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_J_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_J_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_J, ('ls :: hasntJ, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_J_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

definition schem_lift_prod_recR_K_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_K, ('ls, 'rs :: hasntK) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_K_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_K_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_K, ('ls :: hasntK, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_K_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"


definition schem_lift_merge_recR_A_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_A, ('ls, 'rs :: hasntA) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_A_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_A_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_A, ('ls :: hasntA, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_A_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_B_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_B, ('ls, 'rs :: hasntB) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_B_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_B_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_B, ('ls :: hasntB, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_B_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_C_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_C, ('ls, 'rs :: hasntC) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_C_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_C_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_C, ('ls :: hasntC, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_C_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_D_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_D, ('ls, 'rs :: hasntD) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_D_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_D_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_D, ('ls :: hasntD, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_D_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_E_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_E, ('ls, 'rs :: hasntE) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_E_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_E_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_E, ('ls :: hasntE, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_E_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_F_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_F, ('ls, 'rs :: hasntF) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_F_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_F_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_F, ('ls :: hasntF, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_F_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_G_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_G, ('ls, 'rs :: hasntG) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_G_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_G_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_G, ('ls :: hasntG, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_G_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_H_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_H, ('ls, 'rs :: hasntH) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_H_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_H_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_H, ('ls :: hasntH, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_H_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_I_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_I, ('ls, 'rs :: hasntI) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_I_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_I_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_I, ('ls :: hasntI, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_I_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_J_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_J, ('ls, 'rs :: hasntJ) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_J_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_J_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_J, ('ls :: hasntJ, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_J_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

definition schem_lift_merge_recR_K_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_K, ('ls, 'rs :: hasntK) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_K_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_K_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_K, ('ls :: hasntK, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_K_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"


(* currently not using fan liftings *)
(*
definition schem_lift_fan_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'a, 'c :: Pord, 'ls) sfan, 'x, 'a, ('c * 'b2)) schem_lift" where
"schem_lift_fan_recR rec n s =
  (case s of
    SFAN f ls \<Rightarrow>
      prod_fan_l f (rec n ls))"
*)

definition schem_lift_inject ::
  " ('n, ('x, 'a, 'b, 'n) sinject, 'x, 'a, 'b) schem_lift" where
"schem_lift_inject n s =
  (case s of
    SINJ l ls \<Rightarrow> l)"


(*
 * Here is where the merge actually happens. Note that we actually handle then _entire_
 * left-hand-side product as one big merge: we calculate the lifting for each component
 * (into the entire "big" type), then merge them all together.
 *)
(* left-side recursion (merge) *)
definition schem_lift_recL ::
  "('s1l, 's2, 'x, 'a1l, 'b2) schem_lift \<Rightarrow>
   ('s1r, 's2, 'x, 'a1r, 'b2) schem_lift \<Rightarrow>
   (('s1l :: schem, 's1r :: schem) sprod, 's2 :: schem, 'x, 
   (('a1l :: Bogus) * ('a1r :: Bogus)), 'b2 :: Mergeable) schem_lift" where
"schem_lift_recL recl recr s1 s2 =
  (case s1 of
    SP s1l s1r \<Rightarrow>
      merge_l (recl s1l s2) (recr s1r s2))"

(* Overloaded instances for schem_lift.
 * For recursive instances, this is where we can safely "tie the knot",
 * supplying the symbol schem_lift as an argument to its recursive instances.
 *)
adhoc_overloading schem_lift

"schem_lift_base_trivA"
"schem_lift_base_trivB"
"schem_lift_base_trivC"
"schem_lift_base_trivD"
"schem_lift_base_trivE"
"schem_lift_base_trivF"
"schem_lift_base_trivG"
"schem_lift_base_trivH"
"schem_lift_base_trivI"
"schem_lift_base_trivJ"
"schem_lift_base_trivK"

"schem_lift_base_idA"
"schem_lift_base_idB"
"schem_lift_base_idC"
"schem_lift_base_idD"
"schem_lift_base_idE"
"schem_lift_base_idF"
"schem_lift_base_idG"
"schem_lift_base_idH"
"schem_lift_base_idI"
"schem_lift_base_idJ"
"schem_lift_base_idK"

"schem_lift_prod_recR_A_left schem_lift"
"schem_lift_prod_recR_A_right schem_lift"
"schem_lift_prod_recR_B_left schem_lift"
"schem_lift_prod_recR_B_right schem_lift"
"schem_lift_prod_recR_C_left schem_lift"
"schem_lift_prod_recR_C_right schem_lift"
"schem_lift_prod_recR_D_left schem_lift"
"schem_lift_prod_recR_D_right schem_lift"
"schem_lift_prod_recR_E_left schem_lift"
"schem_lift_prod_recR_E_right schem_lift"
"schem_lift_prod_recR_F_left schem_lift"
"schem_lift_prod_recR_F_right schem_lift"
"schem_lift_prod_recR_G_left schem_lift"
"schem_lift_prod_recR_G_right schem_lift"
"schem_lift_prod_recR_H_left schem_lift"
"schem_lift_prod_recR_H_right schem_lift"
"schem_lift_prod_recR_I_left schem_lift"
"schem_lift_prod_recR_I_right schem_lift"
"schem_lift_prod_recR_J_left schem_lift"
"schem_lift_prod_recR_J_right schem_lift"
"schem_lift_prod_recR_K_left schem_lift"
"schem_lift_prod_recR_K_right schem_lift"

"schem_lift_option_recR schem_lift"

"schem_lift_prio_recR schem_lift"

(* "schem_lift_oalist_recR schem_lift" *)

(* "schem_lift_roalist_recR schem_lift" *)

(*"schem_lift_fan_recR schem_lift"*)

"schem_lift_merge_recR_A_left schem_lift"
"schem_lift_merge_recR_A_right schem_lift"
"schem_lift_merge_recR_B_left schem_lift"
"schem_lift_merge_recR_B_right schem_lift"
"schem_lift_merge_recR_C_left schem_lift"
"schem_lift_merge_recR_C_right schem_lift"
"schem_lift_merge_recR_D_left schem_lift"
"schem_lift_merge_recR_D_right schem_lift"
"schem_lift_merge_recR_E_left schem_lift"
"schem_lift_merge_recR_E_right schem_lift"
"schem_lift_merge_recR_F_left schem_lift"
"schem_lift_merge_recR_F_right schem_lift"
"schem_lift_merge_recR_G_left schem_lift"
"schem_lift_merge_recR_G_right schem_lift"
"schem_lift_merge_recR_H_left schem_lift"
"schem_lift_merge_recR_H_right schem_lift"
"schem_lift_merge_recR_I_left schem_lift"
"schem_lift_merge_recR_I_right schem_lift"
"schem_lift_merge_recR_J_left schem_lift"
"schem_lift_merge_recR_J_right schem_lift"
"schem_lift_merge_recR_K_left schem_lift"
"schem_lift_merge_recR_K_right schem_lift"

"schem_lift_recL schem_lift schem_lift"

"schem_lift_inject"



(* convenience abbreviations for priorities *)
abbreviation SPR0 where
"SPR0 x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ _ . 0) x"

abbreviation SPRK where
"SPRK x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ z . z) x"

abbreviation SPRI where
"SPRI x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ z . 1 + z) x"

abbreviation SPRIN where
"SPRIN n x \<equiv>
  SPR (\<lambda> _ . n) (\<lambda> _ z . n + z) x"

(* NB: differs from prio_l_case_inc behavior *)
abbreviation SPRC where
"SPRC f x \<equiv>
  SPR (\<lambda> s . 0) (\<lambda> s z . (f s) + z) x"

end