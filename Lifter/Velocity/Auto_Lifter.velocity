theory Auto_Lifter
    imports Main "../Auto_Lifter_Datatypes" "../../Mergeable/Mergeable" "../Lifter_Instances" 
      "HOL-Library.Adhoc_Overloading"
begin

(* This file implements some (extremely hacky) automation for generating Liftings
 * based on a user-supplied specification. The specification is somewhat more convenient
 * than actually writing out the liftings in full: essentially the user describes a
 * "schema" of names for the "small" type being lifted, and then how those names map into fields of
 * the "larger" type into which it is being lifted.
 *
 * Perhaps surprisingly (given the limitations of Isabelle's typeclass system), we are able
 * to accomplish this translation by (ab)using Isabelle's built-in infrastructure for
 * typeclasses and ad-hoc polymorphism.
 *
 * A rather hand-wavey intuition for how this works is the following:
 * Inference for ad-hoc constants cannot backtrack; at each point during inference,
 * we must be able to pick a direction and have certainty that either we will find a valid
 * instance or fail. Ambiguity (i.e., overlapping instances) at any point will cause a failure.
 * In our case, this happens for instance when descending into a tuple. If we are looking for an
 * instance of the name 'A' in the tuple, we need to be able to know immediately if 'A' is to
 * be found in the first or second component of the tuple, to avoid backtracking.
 *
 * What saves us is that ad-hoc constant inference can be guarded by typeclass constraints,
 * and these constraints can disambiguate what would otherwise be overlapping instances.
 * In our case, if we are able to infer that the first component of the tuple inhabits the
 * "hasntA" typeclass, we can proceed recursively on the second component, without fear
 * of overlaps. In order to make this work, we restrict schema to use a "closed universe"
 * of pre-defined names (though this universe is quite easy to extend; see below).
 *
 * The fact that this all works still feels somewhat magical. Of course, the downside to
 * pushing the limits of the typeclass and ad-hoc polymorphism capabilities of Isabelle
 * is that error-messages are nearly unintelligible.
 *
 * There is some corresponding proof automation for reasoning about liftings generated by
 * the automation here (really just hint sets, nothing too exotic). That automation is in
 * Auto_Lifter_Proofs.thy
 *)


(* We support a limited (but extensible) set of names. *)
(* Each name Z needs the following to be added to the auto-lifter:
   - class n_Z
   - datatype nZ, instantiated at n_Z, basename, and schem
   - a class hasntZ
   - an instantiation of hasntZ for type constructors (i.e., prod, md_prio, etc.)
   - an instantiation of hasntZ for _all_ base-names that are not z
     - yes, this leads to a polynomial number of instance declarations.
   - instances of schem_lift: schem_lift_base_trivZ and schem_lift_base_idZ
     - these must be defined (see e.g. schem_lift_trivA, below), then added to the
       listing of overloaded instances for schem_lift at the end of the file
*)

(* Each name N gets a class n_N *)


#set( $names =
  [ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"])

#foreach ($n in $names)
class n_${n}
#end

(* Class collecting all "base" names. We could perhaps use this more aggressively
 * to clean up some of the inference code *)
class basename


(* each name N gets a dummy datatype NN *)

#foreach ($n in $names)
datatype n${n} = N${n}
#end

datatype nX = NX

#foreach ($n in $names)
instantiation n${n} :: n_${n} begin
instance proof qed
end

instantiation n${n} :: basename begin
instance proof qed
end

#end

(* schem is going to include both names (fields) as well as compound structures *)
class schem

#foreach ($n in $names)
instantiation n${n} :: schem begin
instance proof qed
end

#end

instantiation nX :: schem begin
instance proof qed
end

instantiation sprod :: (schem, schem) schem begin
instance proof qed
end

instantiation sprio :: (_, schem) schem begin
instance proof qed
end

instantiation soption :: (schem) schem begin
instance proof qed
end

instantiation soalist :: (_, linorder, schem) schem begin
instance proof qed
end

instantiation sroalist :: (_, linorder, schem) schem begin
instance proof qed
end

instantiation smerge :: (schem, schem) schem begin
instance proof qed
end

instantiation sfan :: (_, _, _, schem) schem begin
instance proof qed
end

instantiation sinject :: (_ , _, _, schem) schem
begin
instance proof qed
end

instantiation sid :: (schem) schem
begin
instance proof qed
end


#foreach ($n in $names)
class hasnt${n}
#end

#foreach ($n in $names)
instantiation n${n} :: "{
#foreach ($m in $names)
#if($n != $m)hasnt${m},
#end
#end
type}"
begin
instance proof qed
end

#end


(* By convention, we use X to denote names we don't care about (think "_" in pattern-match).
 * For this reason we do not need a "hasntX" typeclass - we will never be searching _for_ X. *)
instantiation nX :: "{
#foreach ($m in $names)
hasnt${m},
#end
type}"
begin
instance proof qed
end


#foreach ($n in $names)
instantiation sprod :: (hasnt${n}, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation sprio :: (_, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation soption :: (hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation soalist :: (_, linorder, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation sroalist :: (_, linorder, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation smerge :: (hasnt${n}, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation sfan :: (_, _, _, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation sinject :: (_, _, _, hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

#foreach ($n in $names)
instantiation sid :: (hasnt${n}) hasnt${n} begin
instance proof qed
end
#end

(* 
 * At this point, we're set up to define a polymorphic constant, schem_lift, that will
 * infer (synthesize, if you like) the correct lifting based on the user's specification.
 * Because this happens at typeclass-instantiation-time, we can only use type-level information
 * when doing this.
 *
 * One notable intricacy here is that most of the instances corresponding to type constructors
 * (e.g. md_prio, prod, ...) are actually _higher-order_: they take (a) lifting(s)
 * corresponding to their contents, and return a lifting for the whole structure.
 * Where do these liftings come from? We "just" infer them in the same way, recursively!
 *
 * Naively we'd want to use the symbol schem_lift inside of its own instance definitions
 * in such cases, but this doesn't work. What we instead have to do looks a bit like
 * what one does when using a fixed-point combinator to encode a recursive function:
 * we define a function that takes as a parameter the recursive instance of itself, which
 * the fixed-point combinator will fill in later. In cases like prod where we have
 * multiple data, we will have one such argument for each call-site (datum). 
 * 
 * I am not fully sure why this trick works; it has something to do with being able to
 * defer the inference of certain constants until it is possible to have enough information
 * to infer it unambiguously.
 *
 * This encoding is a prime culprit in the awfulness of the error messages generated by this
 * contraption :)
 *)

(* Intuitively, the parameters here are (in order):
 * the "left-hand side" schema corresponding to the "small" type
 * the "right-hand side" schema corresponding to the "big" type.
 * This inference feels somewhat like a search, in that for each piece
 * of the left-hand side (of type 's1), we are trying to find a matching piece
 * of the right-hand side (of type 's2) so that we can construct the appropriate
 * lifting.
 *)
type_synonym ('s1, 's2, 'x, 'a, 'b) schem_lift =
"('s1 \<Rightarrow> 's2 \<Rightarrow> ('x, 'a, 'b) lifting)"

consts schem_lift ::
  "('s1 :: schem, 's2 :: schem, 'x, 'a, 'b) schem_lift"


(* TODO: we could probably reduce these by using the basename typeclass.
   not doing this for now in case it is causing a bug. *)


#foreach ($n in $names)
definition schem_lift_base_triv${n} ::  "('n :: n_${n}, 'n, 'x, 'a :: Bogus, 'a md_triv) schem_lift" where
"schem_lift_base_triv${n} _ _ =
  triv_l"
#end

#foreach ($n in $names)
definition schem_lift_base_id${n} ::  "('n :: n_${n}, 'n sid, 'x, 'a :: {Bogus, Pord}, 'a) schem_lift" where
"schem_lift_base_id${n} _ _ =
  id_l"
#end

(* Now we implement some instances for recursion "on the right side"
 * (that is, in the "big" type of the lifting,
 * or the "target" or "result" type if you prefer; 'b2 in the following code).
 * Other than the need to encode the recursive call as a
 * parameter, this is straightforward for liftings corresponding to type-constructors with
 * one type parameter (most notably, not prod)
 *)

(* right-side recursion (prio) *)
definition schem_lift_prio_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'ls) sprio, 'x, 'a, 'b2 md_prio) schem_lift" where
"schem_lift_prio_recR rec n s =
  (case s of
    SPR f1 f2 s' \<Rightarrow>
      prio_l f1 f2 (rec n s'))"

(* right-side recursion (option) *)
definition schem_lift_option_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, 'ls soption, 'x, 'a, 'b2 option) schem_lift" where
"schem_lift_option_recR rec n s =
  (case s of
    SO s' \<Rightarrow>
      option_l (rec n s'))"

(* not currently using oalist_l *)
(*
(* right-side recursion (oalist) *)
definition schem_lift_oalist_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'k :: linorder, 'ls) soalist, 'x, 'a, ('k, 'b2) oalist) schem_lift" where
"schem_lift_oalist_recR rec n s =
  (case s of
    SL f1 s' \<Rightarrow>
      oalist_l f1 (rec n s'))"
*)

(* not currently using roalist_l *)
(*
(* right-side recursion (roalist) *)
(* NB we don't allow lifting into the "inr" data of the roalist.
   a separate lifting could allow this. *)
definition schem_lift_roalist_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'k :: linorder, 'ls) sroalist, 'x, 'a, ('k, 'b2, 'z :: Pord) roalist) schem_lift" where
"schem_lift_roalist_recR rec n s =
  (case s of
    SRL f1 s' \<Rightarrow>
      roalist_l f1 (rec n s'))"
*)

(* The instances for the product type are where all the funny business above about
 * the "hasnt" typeclasses finally come into play. These typeclass constraints
 * labels) are the crucial ingredient here; if we removed them, we would reach an ambiguity
 * when doing inference on _any_ tuple, which Isabelle will not tolerate.
 *
 * For instance, when trying to find NA in (NA, NB), we would get stuck because even though
 * NA is clearly on the left side, we cannot prove that NA doesn't also show up on the right side.
 * Since NB inhabits the hasntA typeclass, however, we avoid this case and can make progress.
 *
 * Put differently, "meaningless" typeclass constraints, in combination with ad-hoc overloading,
 * can be a surprisingly powerful tool for automation.
 *)

(* right-side recursion (prod) *)


#foreach ($n in $names)
definition schem_lift_prod_recR_${n}_left ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_${n}, ('ls, 'rs :: hasnt${n}) sprod, 'x, 'a, 'b2 * ('rest :: Pordb)) schem_lift" where
"schem_lift_prod_recR_${n}_left rec n s =
  (case s of
    SP ls rs =>
      fst_l (rec n ls))"

definition schem_lift_prod_recR_${n}_right ::
  "('n, 'rs, 'x, 'a, 'b2 :: Pord) schem_lift =>
   ('n :: n_${n}, ('ls :: hasnt${n}, 'rs ) sprod, 'x, 'a, ('rest :: Pordb) * ('b2)) schem_lift" where
"schem_lift_prod_recR_${n}_right rec n s =
  (case s of
    SP ls rs =>
      snd_l (rec n rs))"

#end

#foreach ($n in $names)
definition schem_lift_merge_recR_${n}_left ::
  "('n, 'ls, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_${n}, ('ls, 'rs :: hasnt${n}) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_${n}_left rec n s =
  (case s of
    SM ls rs =>
      (rec n ls))"

definition schem_lift_merge_recR_${n}_right ::
  "('n, 'rs, 'x, 'a, 'b2) schem_lift =>
   ('n :: n_${n}, ('ls :: hasnt${n}, 'rs) smerge, 'x, 'a, 'b2) schem_lift" where
"schem_lift_merge_recR_${n}_right rec n s =
  (case s of
    SM ls rs =>
      (rec n rs))"

#end

(* currently not using fan liftings *)
(*
definition schem_lift_fan_recR ::
  "('n, 'ls, 'x, 'a, 'b2 :: Pord) schem_lift \<Rightarrow>
   ('n, ('x, 'a, 'c :: Pord, 'ls) sfan, 'x, 'a, ('c * 'b2)) schem_lift" where
"schem_lift_fan_recR rec n s =
  (case s of
    SFAN f ls \<Rightarrow>
      prod_fan_l f (rec n ls))"
*)

definition schem_lift_inject ::
  " ('n, ('x, 'a, 'b, 'n) sinject, 'x, 'a, 'b) schem_lift" where
"schem_lift_inject n s =
  (case s of
    SINJ l ls \<Rightarrow> l)"


(*
 * Here is where the merge actually happens. Note that we actually handle then _entire_
 * left-hand-side product as one big merge: we calculate the lifting for each component
 * (into the entire "big" type), then merge them all together.
 *)
(* left-side recursion (merge) *)
definition schem_lift_recL ::
  "('s1l, 's2, 'x, 'a1l, 'b2) schem_lift \<Rightarrow>
   ('s1r, 's2, 'x, 'a1r, 'b2) schem_lift \<Rightarrow>
   (('s1l :: schem, 's1r :: schem) sprod, 's2 :: schem, 'x, 
   (('a1l :: Bogus) * ('a1r :: Bogus)), 'b2 :: Mergeable) schem_lift" where
"schem_lift_recL recl recr s1 s2 =
  (case s1 of
    SP s1l s1r \<Rightarrow>
      merge_l (recl s1l s2) (recr s1r s2))"

(* Overloaded instances for schem_lift.
 * For recursive instances, this is where we can safely "tie the knot",
 * supplying the symbol schem_lift as an argument to its recursive instances.
 *)
adhoc_overloading schem_lift

#foreach ($n in $names)
"schem_lift_base_triv${n}"
#end

#foreach ($n in $names)
"schem_lift_base_id${n}"
#end

#foreach ($n in $names)
"schem_lift_prod_recR_${n}_left schem_lift"
"schem_lift_prod_recR_${n}_right schem_lift"
#end

"schem_lift_option_recR schem_lift"

"schem_lift_prio_recR schem_lift"

(* "schem_lift_oalist_recR schem_lift" *)

(* "schem_lift_roalist_recR schem_lift" *)

(*"schem_lift_fan_recR schem_lift"*)

#foreach ($n in $names)
"schem_lift_merge_recR_${n}_left schem_lift"
"schem_lift_merge_recR_${n}_right schem_lift"
#end

"schem_lift_recL schem_lift schem_lift"

"schem_lift_inject"



(* convenience abbreviations for priorities *)
abbreviation SPR0 where
"SPR0 x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ _ . 0) x"

abbreviation SPRK where
"SPRK x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ z . z) x"

abbreviation SPRI where
"SPRI x \<equiv>
  SPR (\<lambda> _ . 0) (\<lambda> _ z . 1 + z) x"

abbreviation SPRIN where
"SPRIN n x \<equiv>
  SPR (\<lambda> _ . n) (\<lambda> _ z . n + z) x"

(* NB: differs from prio_l_case_inc behavior *)
abbreviation SPRC where
"SPRC f x \<equiv>
  SPR (\<lambda> s . f s) (\<lambda> s z . (f s) + z) x"

end